
================================================================================
HABIT TRACKER API - ETAPA 1: USER MODEL + AUTHENTICATION (TDD)
================================================================================

PROIECT: django-habit-tracker-api
AUTOR: Vasili Braila
ABORDARE: TDD (Test-Driven Development)
PHASE: RED → GREEN → REFACTOR

================================================================================
PREREQUISITE - VERIFICARE ETAPA 0
================================================================================
✅ ETAPA 0 completă
✅ Poetry environment activ
✅ Django instalat și configurat
✅ PostgreSQL (postgres-drf) rulează
✅ Database habit_tracker_db disponibil
✅ Aplicații users/ și habits/ create
✅ settings.py are AUTH_USER_MODEL = 'users.User'

VERIFICARE RAPIDĂ:
python manage.py check

AȘTEPTAT: Eroare despre users.User care nu există încă (NORMAL).

================================================================================
OBIECTIVE ETAPA 1
================================================================================
✓ Scriem teste pentru User model (RED PHASE - TDD)
✓ Implementăm Custom User model cu telegram_chat_id (GREEN PHASE)
✓ Creăm și aplicăm migrations
✓ Implementăm serializers pentru User
✓ Implementăm views pentru register
✓ Configurăm URLs pentru authentication
✓ Scriem teste pentru authentication endpoints
✓ Verificăm că toate testele trec (GREEN PHASE)
✓ Coverage > 80% pentru users app

================================================================================
SECȚIUNEA 1: TESTS PENTRU USER MODEL (RED PHASE - TDD)
================================================================================

IMPORTANT: Scriem testele ÎNAINTE de a implementa modelul!
Aceasta este esența TDD - testele vor eșua la început (RED PHASE).

Creează fișierul: users/tests/test_models.py

import pytest
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.mark.django_db
class TestUserModel:
    """Tests pentru Custom User model"""

    def test_create_user_with_email(self):
        """Test: Creare user cu email și password"""
        user = User.objects.create_user(
            email='test@example.com',
            username='testuser',
            password='testpass123'
        )
        assert user.email == 'test@example.com'
        assert user.username == 'testuser'
        assert user.check_password('testpass123')
        assert user.is_active
        assert not user.is_staff
        assert not user.is_superuser

    def test_create_superuser(self):
        """Test: Creare superuser"""
        admin = User.objects.create_superuser(
            email='admin@example.com',
            username='admin',
            password='adminpass123'
        )
        assert admin.email == 'admin@example.com'
        assert admin.is_active
        assert admin.is_staff
        assert admin.is_superuser

    def test_user_email_is_unique(self):
        """Test: Email-ul trebuie să fie unic"""
        User.objects.create_user(
            email='unique@example.com',
            username='user1',
            password='pass123'
        )

        with pytest.raises(Exception):
            User.objects.create_user(
                email='unique@example.com',
                username='user2',
                password='pass456'
            )

    def test_user_str_representation(self):
        """Test: Reprezentarea string a user-ului"""
        user = User.objects.create_user(
            email='test@example.com',
            username='testuser',
            password='pass123'
        )
        assert str(user) == 'test@example.com'

    def test_telegram_chat_id_is_optional(self):
        """Test: telegram_chat_id este opțional"""
        user = User.objects.create_user(
            email='test@example.com',
            username='testuser',
            password='pass123'
        )
        assert user.telegram_chat_id is None

    def test_telegram_chat_id_can_be_set(self):
        """Test: telegram_chat_id poate fi setat"""
        user = User.objects.create_user(
            email='test@example.com',
            username='testuser',
            password='pass123',
            telegram_chat_id='123456789'
        )
        assert user.telegram_chat_id == '123456789'

    def test_user_email_normalization(self):
        """Test: Email-ul este normalizat (lowercase domain)"""
        user = User.objects.create_user(
            email='test@EXAMPLE.COM',
            username='testuser',
            password='pass123'
        )
        assert user.email == 'test@example.com'

================================================================================
SECȚIUNEA 2: RULARE TESTE (RED PHASE)
================================================================================

Rulează testele - AR TREBUI SĂ EȘUEZE (RED PHASE):

pytest users/tests/test_models.py -v

AȘTEPTAT: Erori de tipul:
- AttributeError: module 'users.models' has no attribute 'User'
- django.contrib.auth.models.User has no attribute 'telegram_chat_id'

Aceasta este RED PHASE - testele eșuează pentru că nu am implementat modelul încă!

================================================================================
SECȚIUNEA 3: IMPLEMENTARE USER MODEL (GREEN PHASE)
================================================================================

Acum implementăm modelul pentru a face testele să treacă.

Editează fișierul: users/models.py

ÎNLOCUIEȘTE conținutul cu:

from django.contrib.auth.models import AbstractUser
from django.db import models


class User(AbstractUser):
    """
    Custom User model with email as primary identifier and Telegram support.

    Fields:
        email: Unique email address (used for authentication)
        telegram_chat_id: Telegram chat ID for notifications (optional)

    Authentication:
        USERNAME_FIELD: email (login cu email în loc de username)
        REQUIRED_FIELDS: username (cerut la createsuperuser)
    """

    email = models.EmailField(
        unique=True,
        verbose_name='Email Address',
        help_text='Email address used for authentication'
    )

    telegram_chat_id = models.CharField(
        max_length=100,
        blank=True,
        null=True,
        verbose_name='Telegram Chat ID',
        help_text='Telegram chat ID for habit reminders'
    )

    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = ['username']

    class Meta:
        verbose_name = 'User'
        verbose_name_plural = 'Users'
        ordering = ['-date_joined']

    def __str__(self) -> str:
        """String representation: email address"""
        return self.email

================================================================================
SECȚIUNEA 4: CREARE ȘI APLICARE MIGRATIONS
================================================================================

Creează migrations pentru modelul User:

python manage.py makemigrations users

AȘTEPTAT: "Migrations for 'users': users/migrations/0001_initial.py"

Aplică migrations:

python manage.py migrate

AȘTEPTAT: "Applying users.0001_initial... OK"

Verificare:

python manage.py check

AȘTEPTAT: "System check identified no issues (0 silenced)."

Eroarea AUTH_USER_MODEL ar trebui să dispară complet!

================================================================================
SECȚIUNEA 5: RULARE TESTE (GREEN PHASE)
================================================================================

Rulează testele din nou - AR TREBUI SĂ TREACĂ:

pytest users/tests/test_models.py -v

AȘTEPTAT: Toate testele trec (7 teste verzi)

Dacă toate testele trec - FELICITĂRI! Ai completat GREEN PHASE! ✅

================================================================================
SECȚIUNEA 6: CONFIGURARE ADMIN
================================================================================

Editează fișierul: users/admin.py

ÎNLOCUIEȘTE conținutul cu:

from django.contrib import admin
from django.contrib.auth.admin import UserAdmin as BaseUserAdmin
from .models import User


@admin.register(User)
class UserAdmin(BaseUserAdmin):
    """Admin interface pentru Custom User model"""

    list_display = ['email', 'username', 'is_staff', 'is_active', 'date_joined']
    list_filter = ['is_staff', 'is_active', 'date_joined']
    search_fields = ['email', 'username', 'telegram_chat_id']
    ordering = ['-date_joined']

    fieldsets = (
        (None, {'fields': ('email', 'username', 'password')}),
        ('Personal info', {'fields': ('first_name', 'last_name', 'telegram_chat_id')}),
        ('Permissions', {'fields': ('is_active', 'is_staff', 'is_superuser', 'groups', 'user_permissions')}),
        ('Important dates', {'fields': ('last_login', 'date_joined')}),
    )

    add_fieldsets = (
        (None, {
            'classes': ('wide',),
            'fields': ('email', 'username', 'password1', 'password2'),
        }),
    )

================================================================================
SECȚIUNEA 7: SERIALIZERS PENTRU USER
================================================================================

Creează fișierul: users/serializers.py

from rest_framework import serializers
from django.contrib.auth import get_user_model
from django.contrib.auth.password_validation import validate_password

User = get_user_model()


class UserSerializer(serializers.ModelSerializer):
    """
    Serializer principal pentru User model.
    Folosit pentru operațiuni CRUD pe users.
    """

    password = serializers.CharField(
        write_only=True,
        required=True,
        validators=[validate_password],
        style={'input_type': 'password'}
    )
    password_confirm = serializers.CharField(
        write_only=True,
        required=True,
        style={'input_type': 'password'}
    )

    class Meta:
        model = User
        fields = [
            'id',
            'email',
            'username',
            'password',
            'password_confirm',
            'telegram_chat_id',
            'first_name',
            'last_name',
            'date_joined'
        ]
        read_only_fields = ['id', 'date_joined']

    def validate(self, attrs):
        """Validare: password și password_confirm trebuie să coincidă"""
        if attrs.get('password') != attrs.get('password_confirm'):
            raise serializers.ValidationError({
                'password_confirm': 'Passwords do not match.'
            })
        return attrs

    def create(self, validated_data):
        """Creare user cu password hash-uit"""
        validated_data.pop('password_confirm')
        user = User.objects.create_user(**validated_data)
        return user


class UserPublicSerializer(serializers.ModelSerializer):
    """
    Serializer pentru informații publice despre user.
    Fără date sensibile (password, email complet, etc).
    """

    class Meta:
        model = User
        fields = ['id', 'username', 'first_name', 'last_name']
        read_only_fields = fields

================================================================================
SECȚIUNEA 8: VIEWS PENTRU REGISTRATION
================================================================================

Editează fișierul: users/views.py

ÎNLOCUIEȘTE conținutul cu:

from rest_framework import generics, status
from rest_framework.permissions import AllowAny
from rest_framework.response import Response
from django.contrib.auth import get_user_model
from .serializers import UserSerializer

User = get_user_model()


class UserCreateAPIView(generics.CreateAPIView):
    """
    Endpoint pentru înregistrare user nou.

    POST /api/users/register/

    Permissions: AllowAny (nu trebuie să fii autentificat)
    """

    queryset = User.objects.all()
    serializer_class = UserSerializer
    permission_classes = [AllowAny]

    def create(self, request, *args, **kwargs):
        """Creare user și returnare răspuns"""
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        user = serializer.save()

        return Response(
            {
                'id': user.id,
                'email': user.email,
                'username': user.username,
                'message': 'User created successfully'
            },
            status=status.HTTP_201_CREATED
        )

================================================================================
SECȚIUNEA 9: URLs PENTRU AUTHENTICATION
================================================================================

Creează fișierul: users/urls.py

from django.urls import path
from rest_framework_simplejwt.views import (
    TokenObtainPairView,
    TokenRefreshView
)
from .views import UserCreateAPIView

app_name = 'users'

urlpatterns = [
    path('register/', UserCreateAPIView.as_view(), name='register'),
    path('token/', TokenObtainPairView.as_view(), name='token_obtain_pair'),
    path('token/refresh/', TokenRefreshView.as_view(), name='token_refresh'),
]

================================================================================
SECȚIUNEA 10: CONECTARE URLs ÎN config/urls.py
================================================================================

Editează fișierul: config/urls.py

ÎNLOCUIEȘTE conținutul cu:

from django.contrib import admin
from django.urls import path, include
from rest_framework import permissions
from drf_yasg.views import get_schema_view
from drf_yasg import openapi

schema_view = get_schema_view(
    openapi.Info(
        title="Habit Tracker API",
        default_version='v1',
        description="API for habit tracking with Telegram notifications",
        contact=openapi.Contact(email="vbraila@gmail.com"),
    ),
    public=True,
    permission_classes=[permissions.AllowAny],
)

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/users/', include('users.urls', namespace='users')),
    path('swagger/', schema_view.with_ui('swagger', cache_timeout=0), name='swagger'),
    path('redoc/', schema_view.with_ui('redoc', cache_timeout=0), name='redoc'),
]

================================================================================
SECȚIUNEA 11: TESTS PENTRU AUTHENTICATION ENDPOINTS
================================================================================

Creează fișierul: users/tests/test_api.py

import pytest
from django.contrib.auth import get_user_model
from rest_framework.test import APIClient
from rest_framework import status

User = get_user_model()


@pytest.mark.django_db
class TestUserRegistration:
    """Tests pentru user registration endpoint"""

    def test_register_user_success(self):
        """Test: Înregistrare user cu date valide"""
        client = APIClient()
        data = {
            'email': 'newuser@example.com',
            'username': 'newuser',
            'password': 'SecurePass123!',
            'password_confirm': 'SecurePass123!'
        }

        response = client.post('/api/users/register/', data, format='json')

        assert response.status_code == status.HTTP_201_CREATED
        assert response.data['email'] == 'newuser@example.com'
        assert 'password' not in response.data
        assert User.objects.filter(email='newuser@example.com').exists()

    def test_register_user_password_mismatch(self):
        """Test: Înregistrare eșuează la parole diferite"""
        client = APIClient()
        data = {
            'email': 'test@example.com',
            'username': 'testuser',
            'password': 'SecurePass123!',
            'password_confirm': 'DifferentPass123!'
        }

        response = client.post('/api/users/register/', data, format='json')

        assert response.status_code == status.HTTP_400_BAD_REQUEST

    def test_register_user_duplicate_email(self):
        """Test: Înregistrare eșuează la email duplicat"""
        User.objects.create_user(
            email='existing@example.com',
            username='existing',
            password='pass123'
        )

        client = APIClient()
        data = {
            'email': 'existing@example.com',
            'username': 'newuser',
            'password': 'SecurePass123!',
            'password_confirm': 'SecurePass123!'
        }

        response = client.post('/api/users/register/', data, format='json')

        assert response.status_code == status.HTTP_400_BAD_REQUEST


@pytest.mark.django_db
class TestJWTAuthentication:
    """Tests pentru JWT authentication"""

    def test_obtain_token_success(self):
        """Test: Obținere token cu credențiale valide"""
        user = User.objects.create_user(
            email='test@example.com',
            username='testuser',
            password='testpass123'
        )

        client = APIClient()
        data = {
            'email': 'test@example.com',
            'password': 'testpass123'
        }

        response = client.post('/api/users/token/', data, format='json')

        assert response.status_code == status.HTTP_200_OK
        assert 'access' in response.data
        assert 'refresh' in response.data

    def test_obtain_token_invalid_credentials(self):
        """Test: Obținere token eșuează cu credențiale invalide"""
        client = APIClient()
        data = {
            'email': 'wrong@example.com',
            'password': 'wrongpass'
        }

        response = client.post('/api/users/token/', data, format='json')

        assert response.status_code == status.HTTP_401_UNAUTHORIZED

================================================================================
SECȚIUNEA 12: RULARE TOATE TESTELE
================================================================================

Rulează toate testele pentru users app:

pytest users/tests/ -v

AȘTEPTAT: Toate testele trec (aproximativ 14 teste)

Verificare coverage:

pytest users/tests/ --cov=users --cov-report=term-missing

AȘTEPTAT: Coverage > 80%

================================================================================
SECȚIUNEA 13: CREARE SUPERUSER
================================================================================

Creează un superuser pentru Django Admin:

python manage.py createsuperuser

Când te întreabă:
- Email: admin@example.com
- Username: admin
- Password: Admin123! (de 2 ori)

================================================================================
SECȚIUNEA 14: TEST MANUAL ENDPOINTS
================================================================================

Pornește serverul:

python manage.py runserver

Test endpoints cu browser sau curl:

Swagger: http://127.0.0.1:8000/swagger/
Admin: http://127.0.0.1:8000/admin/

================================================================================
STATUS ETAPA 1 - VERIFICARE FINALĂ
================================================================================

✅ ETAPA 1 COMPLETĂ dacă:

□ User model implementat cu telegram_chat_id
□ Migrations create și aplicate
□ python manage.py check fără erori
□ Toate testele trec: pytest users/tests/ -v
□ Coverage > 80%
□ Admin configurat
□ Serializers create
□ View pentru register funcțional
□ URLs configurate
□ JWT authentication funcționează
□ Swagger documentation disponibilă

================================================================================
URMĂTOAREA ETAPĂ
================================================================================

ETAPA 2: Validators pentru Habit Model (RED PHASE - TDD)

Vom scrie TOATE testele pentru cei 5 validatori ÎNAINTE de implementare!

================================================================================